# Go 语言核心 36 讲

## 开篇词

## 0x00 预习篇

## 0x01 工作区和 GOPATH

- Go1.5 版本实现自举
- Go1.7 版本实现极速 GC
- G1.10 版本对自带工具全面升级（例如程序依赖管理的 `go mod` 命令）
- 在运行 `go build` 命令的时候，**默认不会编译目标代码包所依赖的那些代码包**。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译；如果要强制编译它们，可以在执行命令的时候加入标记 `-a` ；此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此；另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记 `-i` ；
- `go get` 常用标记
    - `-u`：下载并安装代码包，不论工作区中是否已存在它们；
    - `-d`：只下载代码包，不安装代码包；
    - `-fix`：在下载代码包后，先运行一个用于根据当前 Go 语言版本修正代码的工具，然后安装代码包；
    - `-t`：同时下载测试所需的代码包；
    - `-insecure`：允许通过非安全的网络协议下载和安装代码包（如 HTTP 协议）；
- Go 语言官方提供的 `go get` 命令并没有提供依赖管理的功能；
- 提供依赖管理的第三方工具有：
    - glide
    - gb
    - dep
    - vgo
- 有时候，我们可能会处于某种目的**变更存储源码的代码仓库，或者代码包的相对路径**；这时，为了让代码包的远程导入路径不受此类变更的影响，我们会使用**自定义的代码包导入路径**（完整说明详见[这里](https://github.com/hyper0x/go_command_tutorial/blob/master/0.3.md)）；自定义的方法：在代码包中、的库源码文件的、包声明语句的右边，加入导入注释，如 `package semaphore // import 'golang.org/x/sys/semaphore'` ，该代码包原本的、完整导入路径为 `github.com/golang/sync/semaphore` ；加入导入注释后，用 `go get golang.org/x/sys/semaphore` 命令即可下载并安装该代码包；而实际上，在 Go 语言官网 golang.org 下的路径 `/x/sys/semaphore` 并不是存放 semaphore 包的真实地址；不过，这需要在 golang.org 这域名背后的服务端程序上，添加一些支持才行（重定向功能）；


问题：

- 设置 GOPATH 有什么意义？
    - 需要清除 Go 语言源码的组织方式
    - 需要了解源码安装后的结果
    - 需要理解构建和安装 Go 程序的过程
    - 需要清除 go build 命令的一些可选项的用途和用法
- Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？
- 如果在多个工作区中都存在导入路径相同的代码包会产生冲突么？


----------


# go_command_tutorial 摘录

## 03.md

- 命令 `go get` 可以**根据要求和实际情况**，从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装；
- 实际上，`go get` 命令动作也被叫做**代码包远程导入**，而传递给该命令的、作为代码包导入路径的那个参数又被叫做**代码包远程导入路径**；
- `go get` 命令不仅可以从 Github 上下载代码包，还可以从任何命令支持的代码版本控制系统（Version Control System, VCS）检出代码包。更严格地讲，`go get` 命令所做的是从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装；
- `go get` 命令在检出代码包之前，必须要知道代码包远程导入路径所对应的版本控制系统和远程仓库的 URL ；
    - 如果该代码包在本地工作区中已经存在，则会直接通过分析其路径（元数据目录）来确定这几项信息；由于代码包已经存在，只需通过代码版本控制系统的更新命令来更新代码包，因此也就不需要知道其远程仓库的 URL 了；对于已存在于本地工作区的代码包，除非要求强行更新代码包，否则 `go get` 命令不会进行重复下载；
    - 如果本地工作区中不存在该代码包，那么就只能通过对代码包远程导入路径进行分析来获取相关信息了。首先，`go get` 命令会对代码包远程导入路径进行静态分析。为了使分析过程更加方便快捷，`go get` 命令程序中已经预置了几个著名代码托管网站的信息；如果对代码包远程导入路径的静态分析或/和动态分析成功并获取到对应的版本控制系统和远程仓库 URL ，那么 `go get` 命令就会进行代码包检出或更新的操作。随后，`go get` 命令会在必要时以同样的方式检出或更新这个代码包的所有依赖包；
- 一般情况下，为了分离自己与第三方的代码，我们会设置两个或更多的工作区；
- 注意，环境变量 `GOPATH` 中包含的路径不能与环境变量 `GOROOT` 的值重复；
- 如果我们想把一个项目上传到 Github 上并被其他人使用的话，就**应该把这个项目当做一个代码包来看待**；
- 如果你想把你编写的（被托管在不同的代码托管网站上的）**代码包的远程导入路径统一起来**，或者**不希望让你的代码包中夹杂某个代码托管网站的域名**，那么你可以选择**自定义**你的代码包远程导入路径。这种自定义的实现手段叫做“**导入注释**”。例如 `package analyzer // import "hypermind.cn/talon/analyzer"` ；在适当配置后，通过 `go get hypermind.cn/talon/analyzer` 下载代码包，存放路径（包括代码包源码文件以及相应的归档文件的存放路径）会遵循导入注释中的路径，即 `hypermind.cn/talon/analyzer`，而不是原始的导入路径；
- 自定义代码包远程导入路径的好处：Go 语言为了让使用者的项目与代码托管网站隔离所作出了努力，只要你有自己的网站和一个不错的域名，这就很容易搞定并且非常值得。这会在你的代码包的使用者面前强化你的品牌，而不是某个代码托管网站的。当然，使你的代码包导入路径整齐划一是最直接的好处；
- `go get` 命令可以接受所有可用于 `go build` 命令和 `go install` 命令的标记。这是因为 `go get` 命令的内部步骤中完全包含了编译和安装这两个动作；
    - `-d` - 让命令程序只执行下载动作，而不执行安装动作；
    - `-f` - 仅在使用 `-u` 标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 Fork 过来的，那么这样做就尤为重要了；
    - `-fix` - 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装；
    - `-insecure` - 允许命令程序使用非安全的 scheme（如 HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的 Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它；
    - `-t` - 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包；
    - `-u` - 让命令利用网络来更新已有代码包及其依赖包。默认情况下，`go get` 命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包；在执行 `go get` 命令时加入 `-u` 标记就意味着，如果在本地工作区中已存在相关的代码包，那么就是用对应的代码版本控制系统的更新命令更新它，并进行编译和安装。这相当于强行更新指定的代码包及其依赖包；
- `go get` 命令的**智能下载**功能：在使用它检出或更新代码包之后，它会寻找与本地已安装 Go 语言的版本号相对应的标签（tag）或分支（branch）；比如，本机安装 Go 语言的版本是 1.x ，那么 `go get` 命令会在该代码包的远程仓库中寻找名为“go1”的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本；


